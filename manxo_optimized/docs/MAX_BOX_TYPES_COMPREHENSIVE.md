# Max/MSP ボックスタイプ完全ガイド

Max/MSPの視覚的プログラミング環境を構成する基本要素であるボックスタイプについて、その技術的詳細、表現方法、階層構造について詳しく解説します。

## 基本構造から内部表現まで

Max/MSPのパッチは様々なボックスタイプで構成され、それぞれが独自の機能と見た目を持っています。各ボックスはJSONベースの`.maxpat`ファイル内で特定の`maxclass`値によって識別されます。

### オブジェクトボックスとオブジェクトの重要な区別

Max/MSPを理解する上で最も重要な概念の一つは、「オブジェクトボックス」と「オブジェクト」の違いです：

**オブジェクトボックス (Object box)**:
- **定義**: パッチエディタ上に表示される視覚的なコンテナ/フレーム
- **役割**: オブジェクトを格納し表示するための「箱」や「容器」
- **maxclass**: JSONファイル内では常に`"newobj"`として表現される
- **例**: パッチエディタで表示される角の丸い四角形そのもの

**オブジェクト (Object)**:
- **定義**: 実際の処理や機能を持つプログラムの機能単位
- **役割**: 特定の処理や機能を実行する
- **格納場所**: オブジェクトボックスの`text`プロパティの最初の単語
- **例**: `metro`, `+`, `route`, `cycle~`などの具体的な機能を持つ要素

パッチファイル(.maxpat)のJSON表現では次のように区別されます：

```json
{
  "box": {
    "maxclass": "newobj",   // これがオブジェクトボックスの種類
    "text": "metro 500",    // "metro"がオブジェクト、"500"はその引数
    "numinlets": 1,         // インレット数
    "numoutlets": 1,        // アウトレット数
    // 他のプロパティ...
  }
}
```

この構造を理解することは、Max/MSPのパッチを解析・生成する際の基礎となります。同じ「箱」（オブジェクトボックス）でも、中に入っている「中身」（オブジェクト）によって全く異なる機能を持ちます。

### 1. 基本的なボックスタイプとその特徴

#### オブジェクトボックス
- **見た目**: 角の丸い長方形、実線の境界線、通常は白背景に黒テキスト
- **機能**: 特定の処理を実行するMax/MSPの中核要素
- **操作方法**: 'n'キーを押すか、パレットから選択して作成
- **maxclass**: `"newobj"`
- **特筆事項**: オブジェクトボックスは容器であり、実際の機能は内部のオブジェクトによって決まる
- **例**: `metro 500`, `+ 5`, `print`などの機能を含む角丸の長方形
- **JSON表現例**:
```json
{
  "box": {
    "maxclass": "newobj",
    "text": "metro 500",
    "numinlets": 1,
    "numoutlets": 1,
    "outlettype": ["bang"],
    "patching_rect": [100.0, 100.0, 66.0, 22.0],
    "id": "obj-12"
  }
}

#### メッセージボックス
- **見た目**: 長方形で、ロック状態では境界線がなく灰色背景
- **機能**: クリックまたはトリガーされると保存されたメッセージを送信
- **操作方法**: クリックすると保存されたメッセージを送信
- **maxclass**: `"message"`
- **例**: `start`, `$1 Hz`, `; max preempt 1`
- **JSON表現例**:
```json
{
  "box": {
    "maxclass": "message",
    "text": "start",
    "numinlets": 2,
    "numoutlets": 1,
    "outlettype": [""],
    "patching_rect": [50.0, 100.0, 35.0, 22.0],
    "id": "obj-5"
  }
}

#### 数値ボックス
- **見た目**: タイプによって異なる長方形（整数・小数）
- **機能**: 数値の表示と出力
- **種類**:
  - 整数ボックス (**maxclass**: `"number"`)
  - 小数ボックス (**maxclass**: `"flonum"`)
- **例**: 整数（1, 2, 3）、小数（1.5, 2.75）
- **JSON表現例（整数ボックス）**:
```json
{
  "box": {
    "maxclass": "number",
    "numinlets": 1,
    "numoutlets": 2,
    "outlettype": ["int", "bang"],
    "patching_rect": [120.0, 80.0, 50.0, 22.0],
    "id": "obj-7"
  }
}
```
- **JSON表現例（小数ボックス）**:
```json
{
  "box": {
    "maxclass": "flonum",
    "numinlets": 1,
    "numoutlets": 2,
    "outlettype": ["float", "bang"],
    "patching_rect": [180.0, 80.0, 50.0, 22.0],
    "id": "obj-8"
  }
}

#### コメントボックス
- **見た目**: ロック状態では見える境界線なし、編集時に点線の境界線
- **機能**: 説明テキストを表示（データ処理や出力は行わない）
- **maxclass**: `"comment"`
- **例**: 「このセクションは音量を制御します」
- **JSON表現例**:
```json
{
  "box": {
    "maxclass": "comment",
    "text": "このセクションは音量を制御します",
    "numinlets": 1,
    "numoutlets": 0,
    "patching_rect": [10.0, 10.0, 200.0, 20.0],
    "id": "obj-2"
  }
}

#### MSP信号オブジェクト（チルダ～付き）
- **見た目**: オブジェクトボックスに似ているが、名前がチルダ（~）で終わる
- **機能**: サンプルレート（通常44.1kHz）でオーディオ信号を処理
- **maxclass**: `"newobj"` (テキストプロパティでチルダを識別)
- **例**: `cycle~`, `*~`, `dac~`
- **JSON表現例**:
```json
{
  "box": {
    "maxclass": "newobj",
    "text": "cycle~ 440",
    "numinlets": 2,
    "numoutlets": 1,
    "outlettype": ["signal"],
    "patching_rect": [200.0, 150.0, 65.0, 22.0],
    "id": "obj-15"
  }
}

#### UIオブジェクト
- **見た目**: 各UIオブジェクトタイプに合わせたカスタム外観
- **機能**: インタラクティブなコントロール要素の提供
- **maxclass**: それぞれのUI要素に固有の値（`"slider"`, `"toggle"`, `"button"`など）
- **例**: `slider`, `dial`, `toggle`, `multislider`
- **JSON表現例（スライダー）**:
```json
{
  "box": {
    "maxclass": "slider",
    "numinlets": 1,
    "numoutlets": 1,
    "outlettype": ["float"],
    "patching_rect": [300.0, 100.0, 20.0, 140.0],
    "size": 128,
    "id": "obj-20"
  }
}
```
- **JSON表現例（トグル）**:
```json
{
  "box": {
    "maxclass": "toggle",
    "numinlets": 1,
    "numoutlets": 1,
    "outlettype": ["int"],
    "patching_rect": [350.0, 100.0, 24.0, 24.0],
    "id": "obj-22"
  }
}

#### サブパッチャーオブジェクト
- **見た目**: オブジェクトボックスに似ているが、内部にパッチを含む
- **機能**: パッチ内パッチをカプセル化
- **maxclass**: `"newobj"` (テキストが `"p"` または `"patcher"` で始まる)
- **例**: `patcher`, `bpatcher`, `poly~`
- **JSON表現例**:
```json
{
  "box": {
    "maxclass": "newobj",
    "text": "p mySubpatcher",
    "numinlets": 1,
    "numoutlets": 1,
    "outlettype": ["bang"],
    "patching_rect": [400.0, 200.0, 100.0, 22.0],
    "id": "obj-25",
    "patcher": {
      "boxes": {
        // サブパッチャー内のボックス定義
      },
      "lines": {
        // サブパッチャー内の接続定義
      }
    }
  }
}

### 2. maxclassプロパティによるボックスタイプの識別

`maxclass`プロパティは、Max/MSP内でボックスの種類を識別する重要な値です：

- `"newobj"`: 標準的なMaxオブジェクト（非UIオブジェクト）
  - オブジェクト自体の種類は`text`プロパティに格納
  - 例: `metro`, `+`, `p`, `cycle~`などはすべて`"newobj"`だが、機能は異なる
- `"message"`: メッセージボックス
- `"comment"`: テキストコメント
- `"flonum"`: 小数点数ボックス
- `"number"`: 整数ボックス
- `"toggle"`: オン/オフトグルスイッチ
- `"button"`: 瞬間的なバンボタン
- `"slider"`: スライダーUIオブジェクト
- `"ezdac~"`: オーディオ出力オブジェクト
- `"bpatcher"`: 視覚的要素を表示するサブパッチ

**注目すべき点**: UIオブジェクトは独自の`maxclass`値を持ちますが、標準的なオブジェクト（非UI）はすべて`"newobj"`という共通の`maxclass`を共有し、`text`プロパティによって区別されます。

### 3. .maxpatファイル内でのボックスの表現方法

Max/MSPのパッチファイル（`.maxpat`）はJSONベースのフォーマットを使用しており、各ボックスは以下のような構造で表現されます：

```json
{
  "patcher": {
    "boxes": {
      "obj-42": {
        "box": {
          "id": "obj-42",
          "maxclass": "newobj",
          "numinlets": 1,
          "numoutlets": 2,
          "outlettype": ["jit_matrix", ""],
          "patching_rect": [459.0, 29.0, 100.0, 20.0],
          "text": "jit.matrix 4 char 320 240"
        }
      },
      "obj-43": {
        "box": {
          "id": "obj-43",
          "maxclass": "slider",
          "numinlets": 1,
          "numoutlets": 1,
          "outlettype": ["float"],
          "patching_rect": [200.0, 100.0, 20.0, 140.0]
        }
      }
      // 他のボックス定義...
    },
    "lines": {
      // ボックス間の接続定義...
    }
  }
}
```

#### 主要プロパティとその意味

- **`id`**: パッチ内の各ボックスの一意の識別子（通常「obj-」で始まる）
- **`maxclass`**: ボックス/オブジェクトのタイプ
- **`numinlets`**: オブジェクトが持つインレットの数
- **`numoutlets`**: オブジェクトが持つアウトレットの数
- **`outlettype`**: 各アウトレットが生成するデータタイプを定義する配列
- **`patching_rect`**: パッチ内のオブジェクトの位置とサイズ（[左, 上, 幅, 高さ]）
- **`text`**: オブジェクトの表示テキスト内容

#### 「newobj」オブジェクトのテキストプロパティ

「newobj」タイプのオブジェクトでは、`text`プロパティが特に重要です：

- `text`プロパティの最初の単語が実際のMaxオブジェクトの種類を指定
- それ以降の単語はオブジェクトへの引数として渡される

例：
```json
// 400msの間隔を持つmetroオブジェクト
{
  "maxclass": "newobj",
  "text": "metro 400"
}

// 周波数440Hzのcycle~オブジェクト
{
  "maxclass": "newobj",
  "text": "cycle~ 440"
}
```

### 4. 階層構造：サブパッチャー、Abstraction、Bpatcher

Max/MSPでは、以下の要素を使用して階層的なパッチ構造を作成します：

#### サブパッチャー
- 親パッチ内に埋め込まれたパッチャー
- `patcher`または`p`オブジェクトを使用して作成
- 親パッチから直接編集可能
- 変更はすぐに反映（同じファイルの一部のため）
- `.maxpat`ファイル内では、親パッチのJSONに入れ子になった`patcher`オブジェクトとして表現

#### Abstraction（抽象化）
- 別のファイルとして保存され、他のパッチにロード可能な再利用可能なパッチャー
- 抽象化ファイルと同じ名前のオブジェクトを作成して呼び出す
- 抽象化ファイルへの変更は、（再ロード時に）すべてのインスタンスに影響
- `.maxpat`ファイル内では、抽象化への参照として表現され、埋め込みパッチャーデータは含まれない

#### Bpatcher
- サブパッチャーまたは抽象化のユーザーインターフェイスを親パッチ内に直接表示する特殊なオブジェクト
- `bpatcher`オブジェクトを使用して作成
- ロードされたパッチャーの視覚要素を表示
- `.maxpat`ファイル内では、`"maxclass": "bpatcher"`として表され、`name`属性にパッチャーへのパスを含む

#### 階層構造の利点
- **垂直階層**: ツリー構造でパッチを整理（親パッチ→サブパッチ→さらにサブパッチ）
- **モジュール式組織**: 再利用可能なモジュールとして機能
- **情報フロー制御**: インレットとアウトレットを介してレベル間でデータを渡す
- **プロジェクト整理**: 大規模プロジェクトのコード整理に役立つ

### 5. 「newobj」でのオブジェクト名の格納方法

`"newobj"`とされるオブジェクトボックスでは、実際のオブジェクト名は`text`プロパティに格納されます：

1. `text`プロパティは、オブジェクト名とその引数を含む
2. `text`プロパティの最初の単語が、インスタンス化する特定のMaxオブジェクトを識別
3. `text`プロパティの後続の単語はオブジェクトへの引数として渡される

例：
- `"text": "metro 500"` - 500msごとにバンを送信するmetroオブジェクト
   - ここで「metro」がオブジェクト、「500」は引数
- `"text": "p mySubpatch"` - 「mySubpatch」という名前のサブパッチャー
   - ここで「p」がオブジェクト、「mySubpatch」は引数
- `"text": "cycle~ 440"` - 440Hzの周波数を持つサイン波オシレーター
   - ここで「cycle~」がオブジェクト、「440」は引数

このように、同じ「newobj」という`maxclass`を持つオブジェクトボックスでも、内部のオブジェクトによって全く異なる機能を持ちます。一方で、UIオブジェクト（他の`maxclass`値を持つもの）では、オブジェクトタイプは`maxclass`プロパティによって直接指定され、`text`プロパティは異なる意味を持つ場合があります。

## まとめ

Max/MSPのボックスタイプは、各タイプが特有の視覚的外観と機能を持つ多様なセットを形成しています。標準的なオブジェクトから特殊なUIコントロールまで、すべてのボックスはJSONベースの.maxpatファイル形式で表現され、その中で`maxclass`プロパティが中心的な役割を果たしています。特に「newobj」として識別されるオブジェクトでは、具体的なオブジェクトタイプが`text`プロパティの最初の単語によって決定されます。階層構造を形成するサブパッチャー、abstraction、bpatcherはパッチの構成を整理し機能をモジュール化する強力な手段を提供します。これらの要素を理解することで、Max/MSPパッチの作成、解析、修正をより効果的に行うことができます。